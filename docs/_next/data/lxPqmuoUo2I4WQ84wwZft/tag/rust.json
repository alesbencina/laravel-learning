{"pageProps":{"tag":{"id":11,"name":"Rust","url_alias":"rust","created_at":"2023-10-12T12:33:36.000000Z","updated_at":"2023-10-12T12:53:43.000000Z","files":[{"id":119,"name":"1703234786-62526177-3fcb4700-b828-11e9-8c7a-4e31dbf65dc7.png","path":"/uploads/images/1703234786-62526177-3fcb4700-b828-11e9-8c7a-4e31dbf65dc7.png","created_at":"2023-12-22T08:46:26.000000Z","updated_at":"2023-12-22T08:46:26.000000Z","url":"http://laravel-learning.ddev.site/uploads/images/1703234786-62526177-3fcb4700-b828-11e9-8c7a-4e31dbf65dc7.png","pivot":{"tag_id":11,"file_id":119}}],"blogposts":[{"id":25,"title":"Comparing XML Data and Detecting Changes with Rust","description":"<h3><strong>Introduction</strong></h3><p>In a world where data is constantly changing, it's crucial to monitor these shifts.&nbsp;<br>Today, we'll delve into how we used Rust to compare XML data, spot differences, and generate a clear summary of those variances.</p><h3><strong>Why Rust?</strong></h3><p>Rust is a contemporary system programming language promising safety without sacrificing performance. Its powerful type system, zero-cost abstractions, and memory safety guarantees make it a top pick for tasks demanding high performance, like data comparison.</p><h3><strong>Setting the Stage</strong></h3><p>We began with two sets of XML job data. Our mission was to compare them, pinpoint any distinctions, and craft a readable summary. To achieve this, we employed Rust, SQLite for temporary data storage, and hashing to ensure efficient and accurate comparisons.</p><h3><strong>SQLite with Rust:</strong></h3><p>SQLite gave us a nimble solution for transient data storage. With the <code>rusqlite</code> crate, we effortlessly integrated SQLite with Rust.</p><pre><code class=\"php-code\">use rusqlite::{params, Connection};\n\nfn get_connection(db_path: &amp;str) -&gt; rusqlite::Result&lt;Connection&gt; {\n    let conn = Connection::open(db_path)?;\n    Ok(conn)\n}</code></pre><h3><strong>Transactions for Speed:</strong></h3><p>SQLite's transaction mechanism was key in accelerating our database writes. By bundling multiple SQL statements into a single atomic unit, we achieved a remarkable speed boost.</p><pre><code class=\"php-code\">let conn = get_connection(\"xml_compare.db\").unwrap();\nlet tx = conn.transaction().unwrap();\n\nfor job in &amp;jobs {\n    tx.execute(\n        \"INSERT INTO xml_nodes (title, description, ...) VALUES (?1, ?2, ...)\",\n        params![job.title, job.description, ...],\n    )?;\n}\n\ntx.commit()?;</code></pre><h3><strong>Hashing for Efficiency:</strong></h3><p>Instead of comparing lengthy strings head-on, we employed the SHA-256 algorithm to hash data columns, enabling quick and trustworthy comparisons.</p><pre><code class=\"php-code\">use sha2::{Digest, Sha256};\n\nlet title_hash = format!(\"{:x}\", Sha256::digest(job.title.as_bytes()));</code></pre><h3><strong>Error Handling in Rust:</strong></h3><p>Rust's robust error handling, courtesy of the <code>Result</code> type, guaranteed our program's resilience against unforeseen issues.</p><pre><code class=\"php-code\">fn insert_job(conn: &amp;Connection, job: &amp;Job) -&gt; rusqlite::Result&lt;()&gt; {\n    conn.execute(\n        \"INSERT INTO xml_nodes (title, description, ...) VALUES (?1, ?2, ...)\",\n        params![job.title, job.description, ...],\n    )?;\n    Ok(())\n}</code></pre><h3><strong>XML Parsing with Serde:</strong></h3><p>The <code>serde</code> crate simplified our XML parsing and data transformations. We efficiently deserialized XML data into Rust structures and computed hash values seamlessly.</p><pre><code class=\"php-code\">use serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\npub struct Job {\n    title: String,\n    description: String,\n    ...\n}</code></pre><h3><strong>Outcome</strong></h3><p>By strategically employing transactions in our Rust tool, we effectively compared thousands of job entries in under a minute â€” achieving an astonishing 10x speedup in database operations.</p><h3><strong>Conclusion</strong></h3><p>Rust, with its commanding ecosystem, efficient memory management, and robust type guarantees, is a formidable platform for data-heavy tasks. If you're managing vast datasets, require real-time comparisons, or are just navigating the vast realm of system programming, Rust is undeniably a top contender.</p>","url_alias":"rust-serde","tag_id":null,"author_id":16,"status":1,"summary":"Rust was used to compare XML data, leveraging SQLite and SHA-256 hashing. This resulted in a 10x speedup, proving Rust's efficacy for data-heavy tasks.","created_at":"2023-10-12T11:45:29.000000Z","updated_at":"2023-12-22T12:18:07.000000Z","pivot":{"tag_id":11,"blog_id":25},"files":[{"id":120,"name":"1703247253-rs.png","path":"/uploads/images/1703247253-rs.png","created_at":"2023-12-22T12:14:13.000000Z","updated_at":"2023-12-22T12:14:13.000000Z","url":"http://laravel-learning.ddev.site/uploads/images/1703247253-rs.png","pivot":{"blog_post_id":25,"file_id":120}}],"tag":[{"id":11,"name":"Rust","url_alias":"rust","created_at":"2023-10-12T12:33:36.000000Z","updated_at":"2023-10-12T12:53:43.000000Z","pivot":{"blog_id":25,"tag_id":11}}]}]}},"__N_SSG":true}